# What Is Ownership?

- Reference:
  The Rust Programming Language (Book)  
   [Understanding Ownership/What Is Ownership?](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#what-is-ownership)

`Ownership`은 Rust 프로그램이 메모리를 관리하는 방법을 규정하는 일련의 규칙입니다. 모든 프로그램은 실행 중 컴퓨터의 메모리를 사용하는 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행되는 동안 더 이상 사용되지 않는 메모리를 정기적으로 찾는 가비지 컬렉션이 있으며, 다른 언어에서는 프로그래머가 명시적으로 메모리를 할당하고 해제해야 합니다. Rust는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 검사하는 일련의 규칙이 있는 `Ownership` 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램이 컴파일되지 않습니다. `Ownership` 기능 중 어떤 것도 프로그램이 실행되는 동안 속도를 저하시키지 않습니다.

## Ownership Rules

- Rust의 각 값에는 `Owner`가 있습니다.
- `Owner`는 한 번에 한 명만 있을 수 있습니다.
- `Owner`가 범위를 벗어나면 해당 값은 삭제됩니다.

## Variable Scope

`Ownership`의 첫 번째 예시로 변수의 범위를 알아 보겠습니다. 아래에 `s`라는 변수에 `"hello"`라는 값을 할당하는 코드가 있습니다.

```rust
let s = "hello";
```

위의 변수 `s`는 사실 아래와 같이 사용될 것입니다. 주석의 내용을 참고하세요.

```rust
fn main() { // s는 아직 선언되지 않았으므로 여기서 유효하지 않습니다.
    let s = "hello"; // s는 이 지점부터 유효합니다.

    // s로 할 일을 하세요
} // 이 범위는 끝났고 s는 더 이상 유효하지 않습니다.
```

다시 말해, 여기에는 두 가지 중요한 시점이 있습니다:

- s가 범위에 들어오면 유효합니다.
- 범위를 벗어날 때까지 유효합니다.

이 시점에서 범위와 변수가 유효한 시점의 관계는 다른 프로그래밍 언어의 관계와 유사합니다. 이제 이러한 이해를 바탕으로 문자열 유형을 소개하겠습니다.

## The String Type

`Ownership`의 규칙을 설명하기 위해서는, `"Data Types"` 섹션에서 다룬 것보다 복잡한 데이터 유형이 필요합니다. 이전에 다룬 유형은 알려진 크기의 스택에 저장되고 범위가 끝나면 스택에서 빠져나올 수 있으며, 다른 코드 부분이 다른 범위에서 동일한 값을 사용해야 하는 경우 새로운 독립적 인 인스턴스를 만들기 위해 빠르고 간단하게 복사할 수 있습니다. 그러나 우리는 힙에 저장된 데이터를 살펴보고 Rust가 언제 그 데이터를 정리해야 하는지 알아보고 싶습니다. String 유형은 훌륭한 예입니다.

String Type은 힙에 할당된, 변경 가능한, 컴파일 시점에 크기를 알 수 없는 텍스트를 저장할 수 있습니다.

```rust
let s = String::from("hello");
```

이중 콜론 :: 연산자를 사용하면 string_from과 같은 이름을 사용하는 대신 문자열 유형 아래에서 이 특정 from 함수의 네임스페이스를 지정할 수 있습니다. 이 구문에 대해서는 5장의 “Method Syntax” 섹션과 7장의 “Paths for Referring to an Item in the Module Tree”에서 모듈을 사용한 네임스페이스에 대해 설명할 때 자세히 설명하겠습니다.

```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
```

위 코드는 단순 문자 리터럴과 `String`의 차이를 보여주는 예시이며, 이렇게 `String`은 변경할 수 있지만, 문자 리터럴을 이유는 무엇일까요? 그것은, 메모리를 처리하는 방식에 있습니다.

## Memory and Allocation

문자열 리터럴의 경우 컴파일 시점에 내용을 알 수 있으므로 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이것이 바로 문자열 리터럴이 빠르고 효율적인 이유입니다. 하지만 이러한 속성은 문자열 리터럴의 불변성에서 비롯된 것입니다. 안타깝게도 컴파일 시에는 크기를 알 수 없고 프로그램을 실행하는 동안 크기가 변경될 수 있는 각 텍스트 조각에 대해 바이너리에 메모리 덩어리를 넣을 수는 없습니다.

`String` Type을 사용하면 변경 가능하고 확장 가능한 텍스트를 지원하려면 컴파일 시점에 알 수 없는 양의 메모리를 힙에 할당하여 내용을 저장해야 합니다. 즉

- 메모리는 런타임에서 메모리 할당자에게 요청해야 합니다.
- 우리는 `String`을 사용한 후 메모리 할당자에게 이 메모리를 반환하는 방법이 필요합니다.

첫 번째 부분은 우리가 처리합니다. `String::from`을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이는 프로그래밍 언어에서 거의 보편적인 방식입니다.

하지만 두 번째 부분은 다릅니다. 가비지 컬렉터(GC)가 있는 언어에서는 GC가 더 이상 사용되지 않는 메모리를 추적하고 정리하기 때문에 우리는 이에 대해 생각할 필요가 없습니다. GC가 없는 대부분의 언어에서는 메모리가 더 이상 사용되지 않는 시점을 식별하고 요청할 때와 마찬가지로 코드를 호출하여 명시적으로 메모리를 해제하는 것이 개발자의 책임입니다. 이 작업을 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 해제하면 유효하지 않은 변수를 갖게 됩니다. 두 번 수행하면 그것도 버그가 됩니다. 정확히 하나의 할당과 정확히 하나의 여유 공간을 짝을 이루어야 합니다.

Rust는 다른 경로를 사용합니다. 메모리를 소유한 변수가 범위를 벗어나면 메모리가 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 문자열을 사용하는 예시입니다:

```rust
{
    let s = String::from("hello"); // s는 이 시점부터 유효합니다.

    // s로 무언가를 합니다.
}
// 이 스코프는 더 이상 유효하지 않으므로, s는 무효화됩니다.
```

String이 필요로 하는 메모리를 할당자에게 반환할 수 있는 자연스러운 지점이 있습니다: s가 범위를 벗어날 때입니다. 변수가 범위를 벗어나면 Rust는 우리를 위해 특별한 함수를 호출합니다. 이 함수는 drop이라고 하며, String의 저자가 코드를 넣어 메모리를 반환할 수 있습니다. Rust는 닫는 중괄호에서 drop을 자동으로 호출합니다.

Note: C++에서는 항목의 수명이 끝날 때 리소스를 해제하는 이 패턴을 Resource Acquisition Is Initialization (RAII)라고 합니다.

이 패턴은 Rust 코드가 작성되는 방식에 깊은 영향을 미칩니다. 지금은 간단해 보일 수 있지만, 우리가 힙에 할당한 데이터를 여러 변수가 사용하길 원하는 더 복잡한 상황에서 코드의 동작은 예상치 못할 수 있습니다. 이제 그러한 상황을 살펴보겠습니다.

## Variables and Data Interacting with Move

러스트에서 여러 변수는 서로 다른 방식으로 동일한 데이터와 상호 작용할 수 있습니다.

```rust
let x = 5;
let y = x;
```

위 코드는 x에 5를 바인딩하고, 그 다음에 y에 x의 값을 바인딩합니다. 이것은 매우 간단해 보이지만, 이 코드는 무엇을 하는 것일까요? 이 코드는 두 가지를 수행합니다.

- 스택에 5를 넣습니다.
- x에 바인딩합니다.

그런 다음 다음을 수행합니다.

- x의 값을 복사하여 스택에 넣습니다.
- y에 바인딩합니다.

이것은 매우 다른 방식으로 동작합니다. 이것은 러스트가 스택에 있는 모든 데이터가 컴파일 시점에 정확히 얼마나 많은 공간을 차지하는지 알고 있기 때문에 가능합니다. 스택에 있는 데이터는 빠르게 작동하도록 설계되어 있으므로, 이러한 유형의 복사는 매우 빠릅니다. 이것은 또한 x와 y가 독립적으로 작동할 수 있도록 합니다. 만약 x가 값을 변경하면 y는 영향을 받지 않습니다.

이제 이 코드를 String에 적용해 보겠습니다.

```rust
let s1 = String::from("hello");
let s2 = s1;
```

이 경우에는 무엇이 일어날까요? 먼저, 스택에는 두 개의 포인터, 길이 및 용량이 들어갑니다. 이것은 스택에 저장된 데이터입니다.

![image](https://doc.rust-lang.org/book/img/trpl04-01.svg)

그런 다음 s1의 값이 s2에 복사됩니다. 이것은 스택 데이터를 복사하는 것과 같습니다. 이것은 빠르게 수행되며, 우리는 여전히 두 개의 포인터, 길이 및 용량을 가지고 있습니다. 그러나 이제 스택에는 다른 데이터가 있습니다.

![image](https://doc.rust-lang.org/book/img/trpl04-02.svg)

이제 두 개의 String이 스택에 있습니다. 그러나 어떤 데이터가 힙에 있는지는 알 수 없습니다. 이것은 러스트가 스택에 있는 데이터를 복사하는 것만으로는 충분하지 않기 때문입니다. 러스트는 이러한 상황을 어떻게 처리할까요? 러스트는 힙 데이터를 복사하지 않습니다. 대신, 러스트는 s1과 s2가 같은 힙 데이터를 가리키고 있다고 가정합니다. 이것은 러스트가 s1을 무효화할 때, s2는 더 이상 유효하지 않은 포인터를 가지고 있기 때문에 러스트가 s2를 무효화할 때 두 번 메모리를 해제하려고 하지 않도록 하기 위함입니다.

![image](https://doc.rust-lang.org/book/img/trpl04-03.svg)
위 그림은 러스트가 힙 데이터도 복사한다면 메모리가 어떻게 보일지를 보여줍니다. 만약 러스트가 이렇게 한다면, 힙 데이터가 큰 경우에는 s2 = s1 연산이 런타임 성능 면에서 매우 비싸질 수 있습니다.

이전에, 변수가 범위를 벗어나면 러스트는 자동으로 drop 함수를 호출하고 그 변수에 대한 힙 메모리를 정리한다고 말했습니다. 그러나 두번쨰 그림에서는 두 데이터 포인터가 동일한 위치를 가리키고 있다고 보여줍니다. 이것은 문제입니다: s2와 s1이 범위를 벗어나면 두 변수 모두 동일한 메모리를 해제하려고 할 것입니다. 이것은 double free 오류라고 알려져 있으며, 우리가 이전에 언급한 메모리 안전 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상으로 이어질 수 있으며, 이는 잠재적으로 보안 취약점으로 이어질 수 있습니다.

메모리 안전을 보장하기 위해, s2 = s1; 줄 뒤에는 s1이 더 이상 유효하지 않은 것으로 간주합니다. 따라서 s1이 범위를 벗어날 때 Rust는 아무것도 해제할 필요가 없습니다. s2가 생성된 후 s1을 사용하려고 하면 어떻게 되는지 확인해 보세요:

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

이 코드는 컴파일되지 않습니다. s1은 더 이상 유효하지 않기 때문에, s1을 사용하려고 하면 컴파일러는 오류를 발생시킵니다.

```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
```

다른 언어를 사용하면서 shallow copy와 deep copy라는 용어를 들어본 적이 있다면, 포인터, 길이 및 용량을 복사하지만 데이터는 복사하지 않는 것은 shallow copy를 만드는 것처럼 들릴 수 있습니다. 그러나 Rust는 또한 첫 번째 변수를 무효화하기 때문에 shallow copy라고 부르는 대신 move라고 합니다. 이 예제에서는 s1이 s2로 이동되었다고 말할 수 있습니다. 따라서 실제로 일어나는 일은 아래 그림 나와 있습니다.

![image](https://doc.rust-lang.org/book/img/trpl04-04.svg)

이제 문제가 해결되었습니다! s2만 유효하므로 범위를 벗어날 때 이 메모리만으로도 메모리를 확보할 수 있습니다.

또한, 여기에는 암시적인 설계 선택이 있습니다: Rust는 데이터의 "deep" 복사본을 자동으로 생성하지 않습니다. 따라서 자동 복사는 런타임 성능 측면에서 비용이 적게 든다고 가정할 수 있습니다.

## Variables and Data Interacting with Clone

스택 데이터뿐만 아니라 문자열의 힙 데이터까지 깊숙이 복사하고 싶다면 복제라는 일반적인 메서드를 사용할 수 있습니다. 5장에서 메서드 구문에 대해 설명하겠지만, 메서드는 많은 프로그래밍 언어에서 흔히 볼 수 있는 기능이기 때문에 아마 한 번쯤은 보셨을 것입니다.

다음은 실제 복제 방법의 예입니다:

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

## Stack-Only Data: Copy

복제가 아닌 이동이 발생하는 경우는 변수가 스택 데이터만을 가지고 있을 때입니다. 다음 코드를 살펴보세요:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

하지만 이 코드는 방금 배운 내용과 모순되는 것처럼 보입니다. 복제 호출이 없지만 X는 여전히 유효하며 Y로 이동되지 않았습니다.

그 이유는 컴파일 시점에 크기가 알려진 정수 같은 타입은 스택에 전부 저장되므로 실제 값의 복사본을 빠르게 만들 수 있기 때문입니다. 즉, 변수 y를 생성한 후 x가 유효하지 않게 할 이유가 없다는 뜻입니다. 즉, 여기서는 깊은 복사와 얕은 복사 사이에 차이가 없으므로 복제를 호출해도 일반적인 얕은 복사와 달라지는 것이 없으므로 생략해도 됩니다.

Rust에는 정수처럼 스택에 저장된 타입에 복사 특성이라는 특수 어노테이션이 있습니다(10장에서 특성에 대해 자세히 설명하겠습니다). 타입이 Copy 특성을 구현하면 이를 사용하는 변수는 이동하지 않고 살짝 복사되어 다른 변수에 할당된 후에도 여전히 유효합니다.

Rust는 유형 또는 그 일부가 Drop 특성을 구현한 경우 Copy로 유형에 주석을 달 수 없습니다. 값이 범위를 벗어날 때 유형에 특별한 일이 발생해야 하는데 해당 유형에 Copy 어노테이션을 추가하면 컴파일 타임 오류가 발생합니다. 유형에 Copy 어노테이션을 추가하여 특성을 구현하는 방법에 대해 알아보려면 부록 C의 "[파생 가능한 특성](https://doc.rust-lang.org/book/appendix-03-derivable-traits.html)"을 참조하세요.

그렇다면 어떤 유형이 복사 특성을 구현할까요? 해당 유형에 대한 설명서를 확인하여 확인할 수 있지만, 일반적으로 단순한 스칼라 값 그룹은 모두 Copy를 구현할 수 있으며, 할당이 필요하거나 리소스 형태인 어떤 것도 Copy를 구현할 수 없습니다. 다음은 Copy를 구현하는 몇 가지 유형입니다:

- 모든 정수 유형(예: u32).
- 값 참과 거짓이 있는 부울 유형, bool.
- 모든 부동 소수점 유형(예: f64).
- 문자 유형, char.
- 복사도 구현하는 유형만 포함된 경우 튜플. 예를 들어 (i32, i32)는 Copy를 구현하지만 (i32, String)은 구현하지 않습니다.

## Ownership and Functions

함수에 값을 전달하는 메커니즘은 변수에 값을 할당할 때의 메커니즘과 유사합니다. 변수를 함수에 전달하면 할당할 때와 마찬가지로 이동 또는 복사됩니다. 아래에는 변수의 범위 안팎을 보여주는 몇 가지 주석이 있는 예제가 있습니다.

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

takes_ownership을 호출한 후에 s를 사용하려고 하면 Rust는 컴파일 타임 오류를 발생시킵니다. 이러한 정적 검사는 실수로부터 우리를 보호합니다. s와 x를 사용하는 코드를 메인에 추가하여 사용할 수 있는 곳과 소유권 규칙으로 인해 사용할 수 없는 곳을 확인해 보세요.

## Return Values and Scope
값을 반환하면 소유권을 이전할 수도 있습니다. 어노테이션을 사용하여 일부 값을 반환하는 함수의 예입니다.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
변수의 소유권은 매번 동일한 패턴을 따르는데, 값을 다른 변수에 할당하면 변수가 이동합니다. 힙에 데이터가 포함된 변수가 범위를 벗어나면 데이터의 소유권이 다른 변수로 이동되지 않는 한 값이 `drop` 방식으로 정리됩니다.

이 방법은 효과가 있지만 모든 함수에서 소유권을 가져온 다음 소유권을 반환하는 것은 약간 지루합니다. 함수가 값을 사용하되 소유권을 가져가지 않도록 하려면 어떻게 해야 할까요? 우리가 전달한 값을 다시 사용하려면 함수의 본문에서 생성된 데이터뿐만 아니라 반환하고 싶은 데이터도 모두 다시 전달해야 하므로 매우 번거롭습니다.

Rust에서는 튜플을 사용하여 여러 값을 반환할 수 있습니다.

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

그러나 이것은 일반적인 개념에 비해 너무 많은 형식과 많은 작업이 필요합니다. 다행히도 Rust에는 소유권을 이전하지 않고 값을 사용할 수 있는 기능인 레퍼런스라는 기능이 있습니다.
